1. Исполнитель: Дьяченко И.С., гр. 1201
2. Команды компиляции:
arm-gcc -o 4.0.s lab4.c -S -O0
arm-gcc -o 4.3.s lab4.c -S -O3
3. Комментарий:
Основное различие листингов, полученных при компиляции с ключами -О0 и -О3, заключается в организации циклов: В -О0-варианте цикл в листинге организован так же, ка и в исходном коде, при ключе же -О3 цикл выполняется по четыре итерации за один проход (одна итерация ассемблерного цикла соответствует четырем итерациям программы). Также в оптимизированном варианте усложнена проверка на выход из цикла.
4. Исходный код:
#include <stdio.h>

#define N 50000 

int main()
{
	int a[N]={0};

	int i;
	int j;

	for (i=0;i<N;i++)
	{
		scanf("%d",&a[i]);
	}

	for (i=0;i<N;i++)
	{
		for (j=1;j<N;j++)
		{
			if (a[j]<a[j-1])
			{
				int b=a[j];
				a[j]=a[j-1];
				a[j-1]=b;
			}
		}
	}

	for (i=0;i<N;i++)
	{
		printf("%d",&a[i]);
	}

	return 0;
}

5. Ассемблерные листинги:
-О0:
	.arch armv5te
	.fpu softvfp
	.eabi_attribute 20, 1
	.eabi_attribute 21, 1
	.eabi_attribute 23, 3
	.eabi_attribute 24, 1
	.eabi_attribute 25, 1
	.eabi_attribute 26, 2
	.eabi_attribute 30, 6
	.eabi_attribute 34, 0
	.eabi_attribute 18, 4
	.file	"4.c"
	.section	.rodata
	.align	2
.LC0:
	.ascii	"%d\000"
	.text
	.align	2
	.global	main
	.type	main, %function
main:
	.fnstart
.LFB0:
	@ args = 0, pretend = 0, frame = 200016
	@ frame_needed = 1, uses_anonymous_args = 0
	stmfd	sp!, {fp, lr}				положить в стек fp и lr. ! - чтобы указатель обновлялся.
	.save {fp, lr}					создание "описания" регистров, чтобы правильно восстановить
	.setfp fp, sp, #4 				связать описания с местом в sp
	add	fp, sp, #4				fp=sp+4
	.pad #199680					занять место в стеке
	sub	sp, sp, #199680				сдвинуть стек
	.pad #336					еще раз (теперь 200016 байт)
	sub	sp, sp, #336
	ldr	r3, .L11					-200012
	sub	r0, fp, #4				r0=fp+4=sp в прошлом +4
	add	r3, r0, r3				r3=начало стека. в принципе, прям sp
	ldr	r2, .L11+4				r2=размер массива в байтах
	mov	r0, r3					r0=r3=sp+размер+8
	mov	r1, #0					r1=0
	mov	r3, r2					r3=r2=строка+4
	mov	r2, r3					-"-
	bl	memset					вызов. но с какими параметрами?
	mov	r3, #0					r3=0
	str	r3, [fp, #-8]				*(fp-8)=r3
	b	.L2
.L3:
	sub	r3, fp, #199680				r3=fp+199680 (i?) чтение
	sub	r3, r3, #4				r3+=4
	sub	r3, r3, #332				r3+=332. r3==fp+200016==sp
	ldr	r2, [fp, #-8]				r2=i
	mov	r2, r2, asl #2				r2=i*sizeof(int)
	add	r3, r3, r2				r3+=r2. r3==a[i]
	ldr	r0, .L11+8				r0=строка
	mov	r1, r3					r1=a[i]
	bl	scanf					scanf("%d",&a[i])
	ldr	r3, [fp, #-8]				r3=i
	add	r3, r3, #1				r3++
	str	r3, [fp, #-8]				i=r4=i+1
.L2:				внешний цикл
	ldr	r2, [fp, #-8] 				r2=i
	ldr	r3, .L11+12				r3=N 
	cmp	r2, r3					сравнить
	movgt	r3, #0
	movle	r3, #1
	and	r3, r3, #255				
	cmp	r3, #0					сравнить результат сравнения
	bne	.L3					если i<N
	mov	r3, #0					r3=0
	str	r3, [fp, #-8]				i=0
	b	.L4
.L8:			старт внутреннего цикла
	mov	r3, #1					r3=1
	str	r3, [fp, #-12]				j=1?
	b	.L5
.L7:
	ldr	r1, .L11					r1=-200012
	ldr	r3, [fp, #-12]				r3=j
	mov	r3, r3, asl #2				r3=j*sizeof(int)
	sub	ip, fp, #4				ip=fp-4=a+fp
	add	r2, ip, r3				r2=fp-4+r3=&a[j]+fp
	mov	r3, r1					r3=-200012
	add	r3, r2, r3				r3=&a[j] (теперь-то точно хороший адрес)
	ldr	r2, [r3, #0]				r2=a[j]
	ldr	r3, [fp, #-12]				r3=j
	sub	r3, r3, #1				r3=j+1
	ldr	r0, .L11					r0=-200012
	mov	r3, r3, asl #2				
	sub	ip, fp, #4
	add	r1, ip, r3
	mov	r3, r0			
	add	r3, r1, r3
	ldr	r3, [r3, #0]				r3=a[j]
	cmp	r2, r3
	bge	.L6					swap не нужен	
	ldr	r1, .L11					r1=-200012
	ldr	r3, [fp, #-12]				r3=j
	mov	r3, r3, asl #2				r3=j*sizeof(int)
	sub	r0, fp, #4				r0=fp-4=a+x
	add	r2, r0, r3				r2="a+j"
	mov	r3, r1					r3=-200012
	add	r3, r2, r3				r3=&a[j]
	ldr	r3, [r3, #0]				r3=a[j]
	str	r3, [fp, #-16]				"b=a[j]"
	ldr	r3, [fp, #-12]				r3=j
	sub	r3, r3, #1				r3=j+1
	ldr	r1, .L11					r1=-200012
	mov	r3, r3, asl #2				r3=(j+1)*sizeof(int)
	sub	ip, fp, #4				ip=a+fp
	add	r2, ip, r3				r2=&a[j+1]+fp
	mov	r3, r1					r3=-200012
	add	r3, r2, r3				r3=&a[j+1]
	ldr	r2, [r3, #0]				r2=a[j+1]
	ldr	r0, .L11					r0=-200012
	ldr	r3, [fp, #-12]				r3=j
	mov	r3, r3, asl #2				r3=j*sizeof(int)
	sub	ip, fp, #4				ip=a
	add	r1, ip, r3				r1=&a[j]+fp
	mov	r3, r0					r3=r0
	add	r3, r1, r3				r3=&a[j]
	str	r2, [r3, #0]				r2=a[j]
	ldr	r3, [fp, #-12]				r3=j
	sub	r3, r3, #1				r3=j+1
	ldr	r1, .L11					r1=-200012
	mov	r3, r3, asl #2				r3=j*sizeof(int)
	sub	r0, fp, #4				r0=a+fp
	add	r2, r0, r3				r2=&a[j]+fp
	mov	r3, r1					r3=-200012
	add	r3, r2, r3				r3=&a[j]
	ldr	r2, [fp, #-16]				r2=b
	str	r2, [r3, #0]				a[j]=b
.L6:
	ldr	r3, [fp, #-12]
	add	r3, r3, #1			j++
	str	r3, [fp, #-12]
.L5:
	ldr	r2, [fp, #-12] 			r2=j
	ldr	r3, .L11+12			r3=N
	cmp	r2, r3				сравнить
	movgt	r3, #0
	movle	r3, #1
	and	r3, r3, #255			
	cmp	r3, #0
	bne	.L7				запустить тело внутреннего цикла
	ldr	r3, [fp, #-8]
	add	r3, r3, #1			i++
	str	r3, [fp, #-8]
.L4:
	ldr	r2, [fp, #-8]
	ldr	r3, .L11+12
	cmp	r2, r3
	movgt	r3, #0
	movle	r3, #1
	and	r3, r3, #255
	cmp	r3, #0
	bne	.L8				перезапустить цикл по j (с 1)
	mov	r3, #0				
	str	r3, [fp, #-8]			сохранить i
	b	.L9
.L10:
	sub	r3, fp, #199680
	sub	r3, r3, #4
	sub	r3, r3, #332
	ldr	r2, [fp, #-8]
	mov	r2, r2, asl #2
	add	r3, r3, r2
	ldr	r0, .L11+8
	mov	r1, r3
	bl	printf
	ldr	r3, [fp, #-8]
	add	r3, r3, #1
	str	r3, [fp, #-8]
.L9:
	ldr	r2, [fp, #-8]
	ldr	r3, .L11+12
	cmp	r2, r3
	movgt	r3, #0
	movle	r3, #1
	and	r3, r3, #255
	cmp	r3, #0
	bne	.L10
	mov	r3, #0
	mov	r0, r3
	sub	sp, fp, #4
	ldmfd	sp!, {fp, pc}
.L12:
	.align	2
.L11:
	.word	-200012
	.word	200000
	.word	.LC0
	.word	49999
	.fnend
	.size	main, .-main
	.ident	"GCC: (Sourcery CodeBench Lite 2012.03-57) 4.6.3"
	.section	.note.GNU-stack,"",%progbits
-О3:
	.arch armv5te
	.fpu softvfp
	.eabi_attribute 20, 1
	.eabi_attribute 21, 1
	.eabi_attribute 23, 3
	.eabi_attribute 24, 1
	.eabi_attribute 25, 1
	.eabi_attribute 26, 2
	.eabi_attribute 30, 2
	.eabi_attribute 34, 0
	.eabi_attribute 18, 4
	.file	"4.c"
	.section	.text.startup,"ax",%progbits
	.align	2
	.global	main
	.type	main, %function
main:
	.fnstart
.LFB12:
	@ args = 0, pretend = 0, frame = 200000
	@ frame_needed = 0, uses_anonymous_args = 0
	stmfd	sp!, {r4, r5, r6, r7, lr}		сохранение
	.save {r4, r5, r6, r7, lr}
	.pad #199680
	sub	sp, sp, #199680
	.pad #324
	sub	sp, sp, #324				занять 200004 байта
	mov	r0, sp					
	mov	r1, #0
	ldr	r2, .L42				размер
	bl	memset
	ldr	r7, .L42+4				N
	mov	r5, #0					r5=0
	add	r4, sp, #320				r4=sp+320?
.L2:
	add	lr, sp, #0				адрес возврата. зачем?
	add	r1, lr, r5, asl #2			r1=sp+r5*4
	ldr	r0, .L42+8				форматная строка
	bl	scanf					и так 4 раза...
	add	r6, r5, #1
	add	ip, sp, #0
	add	r1, ip, r6, asl #2			
	ldr	r0, .L42+8
	bl	scanf
	add	r0, r5, #2
	add	r2, sp, #0
	add	r1, r2, r0, asl #2
	ldr	r0, .L42+8
	bl	scanf
	add	r1, r5, #3
	add	r3, sp, #0
	ldr	r0, .L42+8
	add	r1, r3, r1, asl #2
	add	r5, r5, #4				как бы i++ (за все 4 раза сразу)
	bl	scanf
	cmp	r5, r7
	bne	.L2					
	add	r1, sp, #199680
	add	lr, r1, #320				lr=sp+200000
.L3:
	sub	r2, r4, #312				r2=sp+8=&a[3]
	rsb	ip, r4, lr				ip=lr-r4=sp+200000-sp-320=200000-320
	ldr	r1, [r4, #-316]				r1=*(sp+4)=a[1] 
	ldr	r0, [r2, #-8]				r0=*(sp)=a[0]
	add	r6, ip, #312				r6=200 000-8=199 992
	mov	r3, r6, lsr #2				r3=r6*4
	cmp	r1, r0					сравнить a[0] и a[1]
	and	r3, r3, #3				последние два бита? кстати, 0 должен быть. оригинальное зануление?
	strlt	r0, [r2, #-4]				если меньше, то обмен
	strlt	r1, [r2, #-8]
.L14:
	cmp	r2, lr
	beq	.L39					сделается r5-- (j--, наверное)
	cmp	r3, #0
	beq	.L5					
	cmp	r3, #1
	beq	.L35
	cmp	r3, #2
	beq	.L36
	add	r2, r2, #4
	ldr	r6, [r4, #-312]
	ldr	r1, [r2, #-8]
	cmp	r6, r1
	strlt	r1, [r2, #-4]
	strlt	r6, [r2, #-8]
.L36:
	ldr	r0, [r2], #4
	ldr	r3, [r2, #-8]
	cmp	r0, r3
	strlt	r3, [r2, #-4]
	strlt	r0, [r2, #-8]
.L35:
	ldr	r3, [r2], #4				r3=a[base+0], r2=&a[base+1]
	ldr	r1, [r2, #-8]				r1=a[base-1]
	cmp	r3, r1					
	bge	.L29
	b	.L40
.L5:
	mov	r3, r2					r3=r2=a[base+0]
	ldr	ip, [r3], #4				ip=*(r3)=a[base+0], r3=r3+4=&a[base+1]
	ldr	r0, [r3, #-8]				r0=a[base-1]
	mov	r2, r3					r2=&a[base+1]
	cmp	ip, r0					a[base-1] a[base+0]	1
	strlt	r0, [r3, #-4]				swap
	strlt	ip, [r3, #-8]
	ldr	r1, [r2], #4				r1=a[base+1],r2=&a[base+2]
	ldr	r0, [r2, #-8]				r0=a[base+0]
	cmp	r1, r0					a[base+1] и a[base+0]	2
	strlt	r0, [r2, #-4]				again
	strlt	r1, [r2, #-8]
.L25:
	mov	r6, r3					r6=&a[base+1]
	ldr	r0, [r3, #4]				r0=a[base+2]
	ldr	ip, [r6], #8				ip=a[base+1], r6=&a[base+3] (r2==&a[base+2], r3==&a[base+1])
	add	r2, r3, #12				r2=&a[base+4]
	cmp	r0, ip					a[base+2] и a[base+1]	3
	stmltdb	r6, {r0, ip}				..., r6=&a[base+1]
	ldr	r3, [r3, #8]				r3=a[base+3]
	ldr	r1, [r2, #-8]				r1=a[base+2]
	cmp	r3, r1					a[base+2] и a[base+3]
	bge	.L29					перепрыгнуть обмен, если не надо
.L40:
	str	r1, [r2, #-4]
	str	r3, [r2, #-8]
.L29:
	cmp	r2, lr					r2==&a[base+4]
	bne	.L5
.L39:
	subs	r5, r5, #1			i--
	bne	.L3				если рано, то повторить цикл
	ldr	r6, .L42+4			r6=N
	mov	r4, r5				r4=r5 (должно быть 0)
.L6:
	add	r5, sp, #0			
	add	r1, r5, r4, asl #2
	ldr	r0, .L42+8
	bl	printf
	add	r5, r4, #1
	add	ip, sp, #0
	add	r1, ip, r5, asl #2
	ldr	r0, .L42+8
	bl	printf
	add	r3, sp, #0
	add	r0, r5, #1
	add	r1, r3, r0, asl #2
	ldr	r0, .L42+8
	bl	printf
	add	r2, r4, #3
	add	r1, sp, #0
	ldr	r0, .L42+8
	add	r1, r1, r2, asl #2
	add	r4, r4, #4
	bl	printf
	cmp	r4, r6
	bne	.L6
	mov	r0, #0
	add	sp, sp, #324
	add	sp, sp, #199680
	ldmfd	sp!, {r4, r5, r6, r7, pc}
.L43:
	.align	2
.L42:
	.word	200000
	.word	50000
	.word	.LC0
	.fnend
	.size	main, .-main
	.section	.rodata.str1.4,"aMS",%progbits,1
	.align	2
.LC0:
	.ascii	"%d\000"
	.ident	"GCC: (Sourcery CodeBench Lite 2012.03-57) 4.6.3"
	.section	.note.GNU-stack,"",%progbits
